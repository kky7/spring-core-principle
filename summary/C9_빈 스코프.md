# 빈 스코프
## 빈 스코프란?
- 빈이 존재할 수 있는 범위
- 싱글톤: 기본 스코프, 스프링 컨테이너의 지작과 종료까지 유지되는 스코프
- 프로토 타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
- 웹 관련 스코프
  - request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  - session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
  - application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

## 싱글톤 스코프 빈 테스트
```java
public class SingletonTest {
    @Test
    void singletonBeanFind(){
       AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SingletonBean.class);
       SingletonBean singletonBean1 = ac.getBean(SingletonBean.class);
       SingletonBean singletonBean2 = ac.getBean(SingletonBean.class);
       System.out.println("singletonBean1 = " + singletonBean1);
       System.out.println("singletonBean2 = " + singletonBean2);
       Assertions.assertThat(singletonBean1).isSameAs(singletonBean2);

       ac.close();
    }

    @Scope("singleton")
    static class SingletonBean {
        @PostConstruct
        public void init(){
            System.out.println("SingletonBean.init");
        }

        @PreDestroy
        public void destroy(){
            System.out.println("SingletonBean.destroy");
        }
    }
}
```
```shell
SingletonBean.init
singletonBean1 = hello.core.scope.SingletonTest$SingletonBean@265adfad
singletonBean2 = hello.core.scope.SingletonTest$SingletonBean@265adfad
08:53:32.585 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@12aba8be, started on Fri Mar 10 08:53:32 KST 2023
SingletonBean.destroy
```
- 빈 초기화 메서드 실행, 같은 인스턴스 빈을 조회, 종료 메서드 정상 호출
- 스프링 컨테이너 생성 시점에 초기화 메서드가 실행 된다.
- 싱글톤 빈은 스프링 컨테이너가 관리하기 때문에 스프링 컨테이너가 종료될 때 빈의 종료 메서드가 실행된다.

## 프로토타입 스코프 빈 테스트
```java
public class PrototypeTest {

    @Test
    void prototypeBeanFind(){
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);
        System.out.println("find prototypeBean1");
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);
        System.out.println("find prototypeBean2");
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);
        System.out.println("prototypeBean1 = " + prototypeBean1);
        System.out.println("prototypeBean2 = " + prototypeBean2);
        Assertions.assertThat(prototypeBean1).isNotSameAs(prototypeBean2);

        ac.close();
    }

    @Scope("prototype")
    static class PrototypeBean {
        @PostConstruct
        public void init(){
            System.out.println("SingletonBean.init");
        }

        @PreDestroy
        public void destroy(){
            System.out.println("SingletonBean.destroy");
        }
    }
}
```
```shell
find prototypeBean1
SingletonBean.init
find prototypeBean2
SingletonBean.init
prototypeBean1 = hello.core.scope.PrototypeTest$PrototypeBean@416c58f5
prototypeBean2 = hello.core.scope.PrototypeTest$PrototypeBean@5505ae1a
08:56:45.280 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@434a63ab, started on Fri Mar 10 08:56:45 KST 2023
```
- 프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행된다.
- 스프링 컨테이너가 생성과 의존관계 주입 그리고 초기화 까지만 관여하고, 더는 관리하지 않는다.
- 스프링 컨테이너가 종료될 때 @PreDestroy 같은 종료 메서드가 실행되지 않는다.
- 스프링 컨테이너에 요청할 때 마다 새로 생성된다.
- 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.